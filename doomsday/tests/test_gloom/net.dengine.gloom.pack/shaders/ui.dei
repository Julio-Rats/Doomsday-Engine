ui {
    # Shader for UI widgets.
    shader guiwidget.batch {
        vertex = "
            uniform mat4  uMvpMatrix;
            uniform vec4  uColor[DENG_MAX_BATCH_UNIFORMS];
            uniform float uSaturation[DENG_MAX_BATCH_UNIFORMS];
            uniform vec4  uScissorRect[DENG_MAX_BATCH_UNIFORMS];

            DENG_ATTRIB vec4 aVertex;
            DENG_ATTRIB vec2 aUV;
            DENG_ATTRIB vec4 aColor;
            DENG_ATTRIB float aIndex; // uColor

            DENG_VAR vec2 vUV;
            DENG_VAR vec4 vColor;
            DENG_VAR vec4 vScissor;
            DENG_VAR float vSaturation;

            void main(void) {
                gl_Position = uMvpMatrix * aVertex;
                vUV = aUV;

                int index = int(aIndex);
                vColor = aColor * uColor[index];
                vScissor = uScissorRect[index];
                vSaturation = uSaturation[index];
            }"
        include.fragment <hsv.glsl>
        fragment = "
            uniform sampler2D uTex;

            DENG_VAR vec2 vUV;
            DENG_VAR vec4 vColor;
            DENG_VAR vec4 vScissor;
            DENG_VAR float vSaturation;

            void main(void) {
                // Check the scissor first.
                if (gl_FragCoord.x < vScissor.x || gl_FragCoord.x > vScissor.z ||
                    gl_FragCoord.y < vScissor.y || gl_FragCoord.y > vScissor.w) {
                    discard;
                }
                out_FragColor = texture(uTex, vUV);

                // Optionally adjust color saturation.
                if (vSaturation < 1.0) {
                    vec4 hsv = rgbToHsv(out_FragColor);
                    hsv.y *= vSaturation;
                    out_FragColor = hsvToRgb(hsv);
                }

                // Final vertex color.
                out_FragColor *= vColor;
            }"
    }
}
