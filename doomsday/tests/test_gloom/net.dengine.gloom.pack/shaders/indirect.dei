group gloom.indirect {
    group textured {
        # Shader with one texture plus a color per vertex. Texture coords
        # are indirectly mapped within the aBounds attribute. Uses a combined
        # model-view-projection matrix. Texture coordinates also repeat within
        # the bounds.
        shader color {
            path.vertex = "common/indirect_textured.vsh"
            fragment = "
                #include 'common/miplevel.glsl'

                uniform sampler2D uTex;
                DENG_VAR vec2 vUV;
                DENG_VAR vec2 vTexSize;
                DENG_VAR vec4 vColor;
                DENG_VAR vec4 vBounds;

                void main(void) {
                    vec2 uv = vBounds.xy + clamp(vUV, vec2(0.0, 0.0), vec2(1.0, 1.0)) * vBounds.zw;
                    vec4 color = vColor * textureLod(uTex, uv, mipLevel(vUV, vTexSize) - 0.5);
                    if (color.a < 0.005) discard;
                    out_FragColor = color;
                }"
        }

        shader emissive {
            path.vertex = "common/indirect_textured.vsh"
            fragment = "
                #include 'common/miplevel.glsl'
                #include 'common/gbuffer_out.glsl'

                uniform sampler2D uTex;
                uniform vec3 uEmissiveIntensity;

                DENG_VAR vec2 vUV;
                DENG_VAR vec2 vTexSize;
                DENG_VAR vec4 vColor;
                DENG_VAR vec4 vBounds;

                void main(void) {
                    vec2 uv = vBounds.xy + clamp(vUV, vec2(0.0, 0.0), vec2(1.0, 1.0)) * vBounds.zw;
                    vec4 color = vColor * textureLod(uTex, uv, mipLevel(vUV, vTexSize) - 0.5);
                    GBuffer_SetFragEmissive(uEmissiveIntensity * color.rgb * color.a);
                }"
        }

        shader color_repeat {
            path.vertex = "common/indirect_textured.vsh"
            fragment = "
                #include 'common/miplevel.glsl'

                uniform sampler2D uTex;
                DENG_VAR vec2 vUV;
                DENG_VAR vec2 vTexSize;
                DENG_VAR vec4 vColor;
                DENG_VAR vec4 vBounds;

                void main(void) {
                    vec2 uv = vBounds.xy + fract(vUV) * vBounds.zw;
                    vec4 color = vColor * textureLod(uTex, uv, mipLevel(vUV, vTexSize) - 0.5);
                    if (color.a < 0.005) discard;
                    out_FragColor = color;
                }"
        }
    }
}
