ui {
    # Shader for UI widgets.
    shader guiwidget.batch {
        vertex = "
            uniform highp mat4  uMvpMatrix;
            uniform highp vec4  uColor[DE_MAX_BATCH_UNIFORMS];
            uniform highp float uSaturation[DE_MAX_BATCH_UNIFORMS];
            uniform highp vec4  uScissorRect[DE_MAX_BATCH_UNIFORMS];

            DE_ATTRIB highp vec4 aVertex;
            DE_ATTRIB highp vec2 aUV;
            DE_ATTRIB highp vec4 aColor;
            DE_ATTRIB highp float aIndex; // uColor

            DE_VAR highp vec2 vUV;
            DE_VAR highp vec4 vColor;
            DE_VAR highp vec4 vScissor;
            DE_VAR highp float vSaturation;

            void main(void) {
                gl_Position = uMvpMatrix * aVertex;
                vUV = aUV;

                int index = int(aIndex);
                vColor = aColor * uColor[index];
                vScissor = uScissorRect[index];
                vSaturation = uSaturation[index];
            }"
        include.fragment <hsv.glsl>
        fragment = "
            uniform sampler2D uTex;

            DE_VAR highp vec2 vUV;
            DE_VAR highp vec4 vColor;
            DE_VAR highp vec4 vScissor;
            DE_VAR highp float vSaturation;

            void main(void) {
                // Check the scissor first.
                if (gl_FragCoord.x < vScissor.x || gl_FragCoord.x > vScissor.z ||
                    gl_FragCoord.y < vScissor.y || gl_FragCoord.y > vScissor.w) {
                    discard;
                }
                out_FragColor = texture(uTex, vUV);

                // Optionally adjust color saturation.
                if (vSaturation < 1.0) {
                    highp vec4 hsv = rgbToHsv(out_FragColor);
                    hsv.y *= vSaturation;
                    out_FragColor = hsvToRgb(hsv);
                }

                // Final vertex color.
                out_FragColor *= vColor;
            }"
    }
}
